<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<script>

var width = 960, height = 500
var numberOfNodes = 100 // number of nodes
var numberOfLinks = parseInt(0.05 * numberOfNodes * numberOfNodes / 2)
var nodeObjects = [];
var linkList = []

var svg = d3.select("body")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

var colors = d3.scaleOrdinal(d3.schemeCategory10);


var simulation = d3.forceSimulation(nodes)
                   .force("charge", d3.forceManyBody().strength(-100))
                   .force("link", d3.forceLink(links).distance(50))

.force("x", d3.forceX())
.force("y", d3.forceY())
.alphaTarget(1)
.on("tick", ticked);

var g = svg.append("g").attr("transform", "translate(" + width / 2 + "," + height / 2 + ")"),
link = g.append("g").attr("stroke", "#000").attr("stroke-width", 1.5).selectAll(".link"),
node = g.append("g").attr("stroke", "#fff").attr("stroke-width", 1.5).selectAll(".node");

//create();
//update();

/*function create () {
  svg.selectAll(".link, .node").remove();
  randomGraph(n, m, charge);
}*/

/*var force = d3.layout
              .force()
              .gravity(.05)
              .distance(100)
              .charge(-100)
              .size([width, height]);*/

//function randomGraph (n, m, charge) {
//console.log(nodeObjects)
setInterval(updateDynamics, 25)

function updateDynamics () {
    var activeNode = randomSelect(nodes)

    // Get all neighbors of the active node
    var neighbors = []
    for (i=0; i<links.length; i++) {
        if (links[i].source == activeNode) {
            neighbors.push(links[i].target);
        }
        else if (links[i].target == activeNode) {
            neighbors.push(links[i].source)
        }
    };

    if (neighbors.length > 0) {
        var activeNeighbor = randomSelect(neighbors)

        if (activeNode.opinion != activeNeighbor.opinion) {
            adaptation(activeNode, activeNeighbor);



                        //console.log(newNeighbor)



        };

    };
    //console.log(links)
    update ();


    console.log(links.length)
}

/*var force = d3.layout.force()
              .size([width, height])
              .nodes(nodeObjects)
              .links(linkList).distance(100).gravity(0.05)
              .charge(-100)
              //.on("tick", ticked)
              .start();*/

var nodes = d3.range(numberOfNodes).map(Object);
var list = randomChoose(unorderedPairs(d3.range(numberOfNodes)), numberOfLinks);
var links = list.map(function (a) { return {source: a[0], target: a[1]} });

console.log(links)

var opinions = randomAssign(d3.range(10), numberOfNodes);
for (var i=0; i<nodes.length; i++) {
    nodes[i].opinion = opinions[i]
}

update ();
function update () {

    node = node.data(nodes)
    node = node.enter().append("circle").attr("fill", function(d) { return colors(d.opinion); }).attr("r", 8).merge(node);

    link = link.data(links)
    link.exit().remove();
    link = link.enter().append("line").merge(link);

    simulation.nodes(nodes);
    simulation.force("link").links(links);
    simulation.alpha(1).restart();
    //drawOpinions();
    //links.style("stroke-width", 3);
};

function ticked () {
        link.attr("x1", function(d) { return d.source.x; })
             .attr("y1", function(d) { return d.source.y; })
             .attr("x2", function(d) { return d.target.x; })
             .attr("y2", function(d) { return d.target.y; });

        node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
}


/*function drawOpinions () {
    nodes.style("fill", function (d) { return colors(d.opinion) });
}*/

function randomAssign (s, k) {
    var a = [], j;
    for (var i=0; i<k; i++) {
        j = Math.floor(Math.random() * s.length);
        a.push(s[j])
    }
    return a;
}

function randomChoose (s, k) { // returns a random k element subset of s
    var a = [], i = -1, j;
    while (++i < k) {
        j = Math.floor(Math.random() * s.length);
        a.push(s.splice(j, 1)[0]);
    };
    return a;
}

function unorderedPairs (s) { // returns the list of all unordered pairs from s
    var a = [];
    for (var i=0; i<s.length; i++) {
        for (var j=i+1; j<s.length; j++) {
            a.push([s[i],s[j]])
        }
    }
    return a;
}

function randomSelect (s) {
    index = Math.floor(Math.random() * s.length);
    return s[index]
}

//randomGraph(n, m, charge);
/*d3.json("graphFile.json", function(json) {
    force.nodes(json.nodes).links(json.links).start();

    var link = svg.selectAll(".link")
                  .data(json.links)
                  .enter()
                  .append("line")
                  .attr("class", "link")
                  .style("stroke-width", function(d) { return Math.sqrt(d.weight); })

    var node = svg.selectAll(".node")
                  .data(json.nodes)
                  .enter()
                  .append("g")
                  .attr("class", "node")
                  .call(force.drag);

    node.append("circle")
        .attr("r","5")

    node.append("text")
        .attr("dx", 12)
        .attr("dy", ".35em")
        .text(function(d) { return d.name });

    force.on("tick", function() {
        link.attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

        node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
      });
    });*/

function adaptation (activeNode, activeNeighbor) {
            var newNeighbors = []
            for (i=0; i<nodes.length; i++) {
                if (nodes[i].opinion == activeNode.opinion) {
                    if (activeNode.index < nodes[i].index) {
                        linkCandidate = {source: activeNode, target: nodes[i]}
                    }
                    else if (activeNode.index > nodes[i].index) {
                        linkCandidate = {target: activeNode, source: nodes[i]}
                    }

                    if (links.includes(linkCandidate) == false) {
                        newNeighbors.push(nodes[i])
                    }
                }
            }
            if (newNeighbors.length > 0) {
                newNeighbor = randomSelect(newNeighbors);

                // Remove the link between the two nodes
                links = links.filter(function(e) {
                    if (activeNode.index < activeNeighbor.index) {
                        result = e.source == activeNode && e.target == activeNeighbor;
                    }
                    else if (activeNode.index > activeNeighbor) {
                        result = e.target == activeNode && e.source == activeNeighbor;
                    }
                    return result == false;
                });

                if (activeNode.index < newNeighbor.index) {
                    linkCandidate = {source: activeNode, target: newNeighbor}
                }
                else if (activeNode.index > newNeighbor.index) {
                    linkCandidate = {target: activeNode, source: newNeighbor}
                }
                links.push(linkCandidate)

            }



};

</script>
</body>
</html>
